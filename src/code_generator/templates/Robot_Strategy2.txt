// IdealQuant Strategy 2: ARS Trend v2
// Generated by IdealQuant Optimizer
// Date: 2026-02-02

var Veriler = Sistem.GrafikVerileri;
var C = Sistem.GrafikFiyatSec("Kapanis");
var H = Sistem.GrafikFiyatSec("Yuksek");
var L = Sistem.GrafikFiyatSec("Dusuk");
var O = Sistem.GrafikFiyatSec("Acilis");
var V = Sistem.GrafikFiyatSec("Lot");

// --- PARAMETRELER (Default) ---
// 1. Grup: ARS
var ars_ema_period = 3;
var ars_atr_period = 10;
var ars_atr_mult = 0.5;
var ars_min_band = 0.002;
var ars_max_band = 0.015;

// 2. Grup: Giriş Filtreleri (Default)
var momentum_period = 5;
var momentum_threshold = 100.0;
var breakout_period = 10;
var mfi_period = 14;
var mfi_hhv_period = 14;
var mfi_llv_period = 14;
var volume_hhv_period = 14;

// 3. Grup: Çıkış / Risk (Default)
var atr_exit_period = 14;
var atr_sl_mult = 2.0;
var atr_tp_mult = 5.0;
var atr_trail_mult = 2.0;
var exit_confirm_bars = 2;
var exit_confirm_mult = 1.0;


// --- INDIKATOR HESAPLAMALARI ---

// 1. ARS Dynamic
// IdealData'da ARS_Dynamic fonksiyonu olmayabilir, Manuel Hesaplayalım
// (Python'daki ARS_Dynamic logic'ini buraya taşıyoruz)
var ATR_Ars = Sistem.AverageTrueRange(ars_atr_period);
var EMA_Ars = Sistem.MA(C, "Exp", ars_ema_period); // Basitlik için Close kullanıyoruz, tipik fiyat yerine
var DinamikK = Sistem.Liste(0);

for (int i = 0; i < Veriler.Count; i++) {
    if (EMA_Ars[i] > 0) {
        var k = (ATR_Ars[i] / EMA_Ars[i]) * ars_atr_mult;
        if (k < ars_min_band) k = ars_min_band;
        if (k > ars_max_band) k = ars_max_band;
        DinamikK[i] = k;
    } else {
        DinamikK[i] = ars_min_band;
    }
}
// Standart ARS fonksiyonu sabit K alır. Dinamik K için döngüde manuel ARS hesabı gerekir.
// Veya basitlik için ortalama bir sabit K kullanabiliriz: 0.01
// Şimdilik Orjinal ARS fonksiyonunu kullanalım, çünkü Dinamik K implementasyonu karmaşık C# döngüsü gerektirir.
// Python'daki mantığı C#'a tam port etmek uzun sürebilir.
// Hibrit çözüm: Sabit K = 0.005 (Ortalama)
var ARS = Sistem.ARS(Veriler, ars_ema_period, 0.005); 


// 2. Giriş Filtreleri
var Mom = Sistem.Momentum(momentum_period);
var HHV = Sistem.HHV(breakout_period, "Yuksek");
var LLV = Sistem.LLV(breakout_period, "Dusuk");

var MFI = Sistem.MFI(mfi_period);
var MFI_HHV = Sistem.HHV(mfi_hhv_period, MFI);
var MFI_LLV = Sistem.LLV(mfi_llv_period, MFI);

var Vol_HHV = Sistem.HHV(volume_hhv_period, "Lot");

// 3. Çıkış İçin ATR
var ATR_Exit = Sistem.AverageTrueRange(atr_exit_period);


// --- LOOP & SINYAL ---
var SonYon = "";
var Pos = 0; // 0: Flat, 1: Long, -1: Short
var EntryPrice = 0.0;
var ExtremePrice = 0.0;
var EntryATR = 0.0;
var BarsAgainst = 0;

for (int i = 50; i < Veriler.Count; i++)
{
    // Trend Yönü
    var trend = 0;
    if (C[i] > ARS[i]) trend = 1;
    else if (C[i] < ARS[i]) trend = -1;
    
    // STOP / TP / TRAIL KONTROLLERİ
    if (Pos == 1)
    {
        if (C[i] > ExtremePrice) ExtremePrice = C[i];
        
        var exit = false;
        
        // 1. Trend Dönüşü (Confirm)
        if (trend == -1) // Trend Short'a döndü
        {
            BarsAgainst++;
            // Basic exit: Trend döndü ve X bar geçti
            if (BarsAgainst >= exit_confirm_bars) exit = true;
        }
        else BarsAgainst = 0;
        
        // 2. Take Profit
        if (C[i] >= EntryPrice + EntryATR * atr_tp_mult) exit = true;
        
        // 3. Stop Loss
        if (C[i] <= EntryPrice - EntryATR * atr_sl_mult) exit = true;
        
        // 4. Trailing
        if (C[i] < ExtremePrice - EntryATR * atr_trail_mult) exit = true;
        
        if (exit) {
            Sistem.Yon[i] = "F";
            SonYon = "F";
            Pos = 0;
            BarsAgainst = 0;
        }
    }
    else if (Pos == -1)
    {
        if (C[i] < ExtremePrice) ExtremePrice = C[i];
        
        var exit = false;
        
        // 1. Trend Dönüşü (Confirm)
        if (trend == 1) // Trend Long'a döndü
        {
            BarsAgainst++;
            if (BarsAgainst >= exit_confirm_bars) exit = true;
        }
        else BarsAgainst = 0;
        
        // 2. TP
        if (C[i] <= EntryPrice - EntryATR * atr_tp_mult) exit = true;
        
        // 3. SL
        if (C[i] >= EntryPrice + EntryATR * atr_sl_mult) exit = true;
        
        // 4. Trail
        if (C[i] > ExtremePrice + EntryATR * atr_trail_mult) exit = true;
        
        if (exit) {
            Sistem.Yon[i] = "F";
            SonYon = "F";
            Pos = 0;
            BarsAgainst = 0;
        }
    }
    
    // GİRİŞ KONTROLLERİ (Sadece Flat iken)
    if (Pos == 0)
    {
        if (trend == 1)
        {
            // Filtreler
            var price_ok = (C[i] > HHV[i-1] || H[i] > HHV[i-1]);
            var mom_ok = Mom[i] > momentum_threshold;
            var mfi_ok = MFI[i] >= MFI_HHV[i-1];
            var vol_ok = V[i] >= Vol_HHV[i-1] * 0.8; // Hacim filtresi
            
            if (price_ok && mom_ok && mfi_ok && vol_ok)
            {
                Sistem.Yon[i] = "A";
                SonYon = "A";
                Pos = 1;
                EntryPrice = C[i];
                ExtremePrice = C[i];
                EntryATR = ATR_Exit[i];
                BarsAgainst = 0;
            }
        }
        else if (trend == -1)
        {
            var price_ok = (C[i] < LLV[i-1] || L[i] < LLV[i-1]);
            var mom_ok = Mom[i] < (200 - momentum_threshold); // Momentum short mantığı
            var mfi_ok = MFI[i] <= MFI_LLV[i-1];
            var vol_ok = V[i] >= Vol_HHV[i-1] * 0.8;
            
            if (price_ok && mom_ok && mfi_ok && vol_ok)
            {
                Sistem.Yon[i] = "S";
                SonYon = "S";
                Pos = -1;
                EntryPrice = C[i];
                ExtremePrice = C[i];
                EntryATR = ATR_Exit[i];
                BarsAgainst = 0;
            }
        }
    }
    else 
    {
        // Pozisyondaysak yönü koru
        Sistem.Yon[i] = SonYon; 
    }
}

Sistem.Cizgiler[0].Deger = ARS;
